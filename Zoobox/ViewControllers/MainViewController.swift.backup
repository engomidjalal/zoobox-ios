import UIKit
import WebKit
import AVFoundation
import CoreLocation

class MainViewController: UIViewController {
    private var webView: NoZoomWKWebView!

    private var refreshControl: UIRefreshControl!
    private var isRefreshing = false
    private var currentNavigation: WKNavigation?
    private var retryCount = 0
    private var lastError: Error?
    private var loadingTimer: Timer?
    private var isWebViewLoaded = false
    private var pendingJSResponses: [String] = []

    
    // Device-specific timeout and retry values
    private var maxRetryCount: Int {
        return UIDevice.current.maxRetryCount
    }
    
    private var loadingTimeout: TimeInterval {
        return UIDevice.current.webViewTimeout
    }
    
    private var isLoading = false
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        print("üîÑ [MainViewController] viewDidLoad called")
        print("‚è∞ [MainViewController] viewDidLoad time: \(Date())")
        
        // Set up white background for top safe area
        setupTopSafeAreaBackground()
        
        setupRefreshControl()
        setupWebView()
        setupConnectivityManager()
        setupNotificationObservers()
        
        // Remove bottom safe area completely
        additionalSafeAreaInsets = UIEdgeInsets(top: 0, left: 0, bottom: -view.safeAreaInsets.bottom, right: 0)
        
        print("‚úÖ [MainViewController] viewDidLoad completed")
    }
    
    private func setupTopSafeAreaBackground() {
        // Create a white background view for the top safe area
        let topSafeAreaView = UIView()
        topSafeAreaView.backgroundColor = UIColor.white
        topSafeAreaView.translatesAutoresizingMaskIntoConstraints = false
        
        view.addSubview(topSafeAreaView)
        
        NSLayoutConstraint.activate([
            topSafeAreaView.topAnchor.constraint(equalTo: view.topAnchor),
            topSafeAreaView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            topSafeAreaView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            topSafeAreaView.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor)
        ])
    }
    

    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        print("üîÑ [MainViewController] viewWillAppear called")
        print("‚è∞ [MainViewController] viewWillAppear time: \(Date())")
        ConnectivityManager.shared.startMonitoring()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        print("üîÑ [MainViewController] viewDidAppear called")
        print("‚è∞ [MainViewController] viewDidAppear time: \(Date())")
        
        // Keep loading indicator visible until webview starts loading
        print("üì± [MainViewController] Keeping loading indicator visible until webview starts")
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        ConnectivityManager.shared.stopMonitoring()
    }
    

    

    
    override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) {
        super.viewWillTransition(to: size, with: coordinator)
        
        print("üì± [MainViewController] Orientation change detected")
        print("üì± [MainViewController] New size: \(size)")
        print("üì± [MainViewController] Device: \(UIDevice.current.deviceFamily)")
        print("üì± [MainViewController] Orientation: \(UIDevice.current.orientationString)")
        

    }
    
    deinit {
        // Remove message handlers safely
        if let webView = webView {
            webView.configuration.userContentController.removeScriptMessageHandler(forName: "hapticFeedback")
            webView.configuration.userContentController.removeScriptMessageHandler(forName: "permissionBridge")
        }
        
        // Remove notification observers
        NotificationCenter.default.removeObserver(self, name: NSNotification.Name("OpenDeepLinkURL"), object: nil)
        
        // Cancel loading timer
        loadingTimer?.invalidate()
        loadingTimer = nil
        
        // Clear pending JavaScript responses
        pendingJSResponses.removeAll()
        
        // Clear WebView reference to prevent crashes
        webView = nil
        
        print("üîê MainViewController deallocated")
    }
    
    private func setupRefreshControl() {
        // Create refresh control with device-specific styling
        refreshControl = UIRefreshControl()
        
        // Device-specific refresh control styling
        let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
        let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
        
        refreshControl.attributedTitle = NSAttributedString(
            string: "Pull to refresh",
            attributes: [
                .foregroundColor: UIColor.systemBlue,
                .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            ]
        )
        
        refreshControl.addTarget(self, action: #selector(handleRefresh), for: .valueChanged)
        // Note: refreshControl will be added to webView.scrollView after WebView is created
    }
    
    private func setupWebView() {
        print("üîÑ [MainViewController] Setting up WebView")
        
        do {
            // Create WebView configuration with error handling
            let configuration = WKWebViewConfiguration()
            
            // Add safety check for configuration
            print("üì± [WebView] Configuration created successfully")
        
        // Device-specific WebView configuration
        if UIDevice.current.isIPad {
            print("üì± [WebView] Applying iPad-specific configuration")
            
            // iPad-specific process pool configuration
            configuration.processPool = WKProcessPool()
            print("üì± [WebView] iPad process pool configured")
            
            // iPad-specific user content controller
            let userContentController = WKUserContentController()
            print("üì± [WebView] iPad user content controller created")
            
            // Add haptic feedback bridge for iPad
            userContentController.add(self, name: "hapticFeedback")
            print("üì± [WebView] iPad haptic feedback bridge added")
            
            // Set user content controller
            configuration.userContentController = userContentController
            print("üì± [WebView] iPad user content controller set")
            
            // Prevent permission dialogs by setting media types that don't require user action
            configuration.mediaTypesRequiringUserActionForPlayback = []
            print("üì± [WebView] iPad media types requiring user action set to empty")
            
            // Additional settings to prevent permission dialogs
            configuration.allowsInlineMediaPlayback = true
            configuration.allowsAirPlayForMediaPlayback = true
            print("üì± [WebView] iPad inline media and airplay settings configured")
            
            // Inject iPad-specific viewport meta tag and disable zoom
            print("üì± [WebView] Creating iPad viewport script")
            let viewportScript = WKUserScript(
                source: """
                var viewport = document.querySelector('meta[name="viewport"]');
                if (!viewport) {
                    viewport = document.createElement('meta');
                    viewport.name = 'viewport';
                    document.head.appendChild(viewport);
                }
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover';
                
                // Disable zoom gestures
                document.addEventListener('gesturestart', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('gesturechange', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('gestureend', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                // Disable double-tap zoom
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
                
                // Disable long-press context menu on all elements
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                // Disable long-press on links and buttons
                document.addEventListener('touchstart', function(e) {
                    // Prevent long-press on interactive elements
                    const target = e.target;
                    if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.getAttribute('role') === 'button' || target.onclick) {
                        // Set a timer to prevent long-press
                        const timer = setTimeout(function() {
                            // This will prevent the long-press menu
                        }, 500);
                        
                        // Clear timer on touch end
                        const clearTimer = function() {
                            clearTimeout(timer);
                            document.removeEventListener('touchend', clearTimer);
                            document.removeEventListener('touchcancel', clearTimer);
                        };
                        
                        document.addEventListener('touchend', clearTimer, { once: true });
                        document.addEventListener('touchcancel', clearTimer, { once: true });
                    }
                }, { passive: true });
                """,
                injectionTime: .atDocumentStart,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(viewportScript)
            print("üì± [WebView] iPad viewport script added")
            
            // Inject iPad-specific CSS for better layout
            print("üì± [WebView] Creating iPad CSS script")
            let cssScript = WKUserScript(
                source: """
                var style = document.createElement('style');
                style.textContent = `
                    html, body {
                        touch-action: manipulation;
                        -ms-touch-action: manipulation;
                    }
                    body { 
                        -webkit-text-size-adjust: 100%; 
                        -webkit-tap-highlight-color: transparent;
                        margin: 0;
                        padding: 0;
                        overflow-x: hidden;
                    }
                    * { 
                        -webkit-touch-callout: none;
                        -webkit-user-select: none;
                        user-select: none;
                    }
                    input, textarea { 
                        -webkit-user-select: text;
                        user-select: text;
                    }
                `;
                document.head.appendChild(style);
                """,
                injectionTime: .atDocumentStart,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(cssScript)
            print("üì± [WebView] iPad CSS script added")
            
            // Inject iPad-specific haptic feedback script
            print("üì± [WebView] Creating iPad haptic feedback script")
            let hapticScript = WKUserScript(
                source: """
                // Haptic feedback for interactive elements - only on actual taps/clicks
                function addHapticFeedback() {
                    // Select all interactive elements
                    const interactiveElements = document.querySelectorAll('a, button, input, select, textarea, [role="button"], [tabindex], [onclick], [onmousedown], [ontouchstart]');
                    
                    interactiveElements.forEach(function(element) {
                        let touchStartTime = 0;
                        let touchStartY = 0;
                        let touchStartX = 0;
                        let hasMoved = false;
                        
                        // Track touch start
                        element.addEventListener('touchstart', function(e) {
                            touchStartTime = Date.now();
                            touchStartY = e.touches[0].clientY;
                            touchStartX = e.touches[0].clientX;
                            hasMoved = false;
                        }, { passive: true });
                        
                        // Track touch move to detect scrolling
                        element.addEventListener('touchmove', function(e) {
                            const currentY = e.touches[0].clientY;
                            const currentX = e.touches[0].clientX;
                            const deltaY = Math.abs(currentY - touchStartY);
                            const deltaX = Math.abs(currentX - touchStartX);
                            
                            // If moved more than 10px, consider it a scroll
                            if (deltaY > 10 || deltaX > 10) {
                                hasMoved = true;
                            }
                        }, { passive: true });
                        
                        // Only trigger haptic feedback on actual taps (not scrolls)
                        element.addEventListener('touchend', function(e) {
                            const touchEndTime = Date.now();
                            const touchDuration = touchEndTime - touchStartTime;
                            
                            // Only trigger if:
                            // 1. Touch duration is less than 300ms (quick tap)
                            // 2. No significant movement (not a scroll)
                            // 3. Touch ended on the same element
                            if (touchDuration < 300 && !hasMoved && e.target === element) {
                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                }
                            }
                        }, { passive: true });
                        
                        // For mouse events (iPad with mouse), use click instead of mousedown
                        element.addEventListener('click', function(e) {
                            // Only trigger if it's a real click (not programmatic)
                            if (e.isTrusted) {
                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                }
                            }
                        }, { passive: true });
                    });
                    
                    // Also handle dynamically added elements
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.addedNodes.forEach(function(node) {
                                if (node.nodeType === 1) { // Element node
                                    const newInteractiveElements = node.querySelectorAll ? node.querySelectorAll('a, button, input, select, textarea, [role="button"], [tabindex], [onclick], [onmousedown], [ontouchstart]') : [];
                                    newInteractiveElements.forEach(function(element) {
                                        let touchStartTime = 0;
                                        let touchStartY = 0;
                                        let touchStartX = 0;
                                        let hasMoved = false;
                                        
                                        // Track touch start
                                        element.addEventListener('touchstart', function(e) {
                                            touchStartTime = Date.now();
                                            touchStartY = e.touches[0].clientY;
                                            touchStartX = e.touches[0].clientX;
                                            hasMoved = false;
                                        }, { passive: true });
                                        
                                        // Track touch move to detect scrolling
                                        element.addEventListener('touchmove', function(e) {
                                            const currentY = e.touches[0].clientY;
                                            const currentX = e.touches[0].clientX;
                                            const deltaY = Math.abs(currentY - touchStartY);
                                            const deltaX = Math.abs(currentX - touchStartX);
                                            
                                            // If moved more than 10px, consider it a scroll
                                            if (deltaY > 10 || deltaX > 10) {
                                                hasMoved = true;
                                            }
                                        }, { passive: true });
                                        
                                        // Only trigger haptic feedback on actual taps (not scrolls)
                                        element.addEventListener('touchend', function(e) {
                                            const touchEndTime = Date.now();
                                            const touchDuration = touchEndTime - touchStartTime;
                                            
                                            // Only trigger if:
                                            // 1. Touch duration is less than 300ms (quick tap)
                                            // 2. No significant movement (not a scroll)
                                            // 3. Touch ended on the same element
                                            if (touchDuration < 300 && !hasMoved && e.target === element) {
                                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                                }
                                            }
                                        }, { passive: true });
                                        
                                        // For mouse events (iPad with mouse), use click instead of mousedown
                                        element.addEventListener('click', function(e) {
                                            // Only trigger if it's a real click (not programmatic)
                                            if (e.isTrusted) {
                                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                                }
                                            }
                                        }, { passive: true });
                                    });
                                }
                            });
                        });
                    });
                    
                    observer.observe(document.body, { childList: true, subtree: true });
                }
                
                // Initialize haptic feedback when DOM is ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', addHapticFeedback);
                } else {
                    addHapticFeedback();
                }
                
                // Also run on page load for single-page applications
                window.addEventListener('load', addHapticFeedback);
                """,
                injectionTime: .atDocumentEnd,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(hapticScript)
            print("üì± [WebView] iPad haptic feedback script added")
            
            configuration.userContentController = userContentController
            print("üì± [WebView] iPad user content controller assigned")
            
            // iPad-specific application name
            configuration.applicationNameForUserAgent = "Zoobox iPad"
            print("üì± [WebView] iPad user agent set")
            
        } else {
            // iPhone-specific configuration
            print("üì± [WebView] Applying iPhone-specific configuration")
            
            // iPhone-specific user content controller
            let userContentController = WKUserContentController()
            print("üì± [WebView] iPhone user content controller created")
            
            // Add haptic feedback bridge for iPhone
            userContentController.add(self, name: "hapticFeedback")
            print("üì± [WebView] iPhone haptic feedback bridge added")
            
            // Set user content controller
            configuration.userContentController = userContentController
            print("üì± [WebView] iPhone user content controller set")
            
            // Prevent permission dialogs by setting media types that don't require user action
            configuration.mediaTypesRequiringUserActionForPlayback = []
            print("üì± [WebView] iPhone media types requiring user action set to empty")
            
            // Additional settings to prevent permission dialogs
            configuration.allowsInlineMediaPlayback = true
            print("üì± [WebView] iPhone inline media settings configured")
            
            // Inject iPhone-specific viewport meta tag and disable zoom
            print("üì± [WebView] Creating iPhone viewport script")
            let viewportScript = WKUserScript(
                source: """
                var viewport = document.querySelector('meta[name="viewport"]');
                if (!viewport) {
                    viewport = document.createElement('meta');
                    viewport.name = 'viewport';
                    document.head.appendChild(viewport);
                }
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no, viewport-fit=cover';
                
                // Disable zoom gestures
                document.addEventListener('gesturestart', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('gesturechange', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                document.addEventListener('gestureend', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                // Disable double-tap zoom
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(event) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        event.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
                
                // Disable long-press context menu on all elements
                document.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                // Disable long-press on links and buttons
                document.addEventListener('touchstart', function(e) {
                    // Prevent long-press on interactive elements
                    const target = e.target;
                    if (target.tagName === 'A' || target.tagName === 'BUTTON' || target.getAttribute('role') === 'button' || target.onclick) {
                        // Set a timer to prevent long-press
                        const timer = setTimeout(function() {
                            // This will prevent the long-press menu
                        }, 500);
                        
                        // Clear timer on touch end
                        const clearTimer = function() {
                            clearTimeout(timer);
                            document.removeEventListener('touchend', clearTimer);
                            document.removeEventListener('touchcancel', clearTimer);
                        };
                        
                        document.addEventListener('touchend', clearTimer, { once: true });
                        document.addEventListener('touchcancel', clearTimer, { once: true });
                    }
                }, { passive: true });
                """,
                injectionTime: .atDocumentStart,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(viewportScript)
            print("üì± [WebView] iPhone viewport script added")
            
            // Inject iPhone-specific CSS
            print("üì± [WebView] Creating iPhone CSS script")
            let cssScript = WKUserScript(
                source: """
                var style = document.createElement('style');
                style.textContent = `
                    html, body {
                        touch-action: manipulation;
                        -ms-touch-action: manipulation;
                    }
                    body { 
                        -webkit-text-size-adjust: 100%; 
                        -webkit-tap-highlight-color: transparent;
                        margin: 0;
                        padding: 0;
                        overflow-x: hidden;
                    }
                    * { 
                        -webkit-touch-callout: none;
                        -webkit-user-select: none;
                        user-select: none;
                    }
                    input, textarea { 
                        -webkit-user-select: text;
                        user-select: text;
                    }
                `;
                document.head.appendChild(style);
                """,
                injectionTime: .atDocumentStart,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(cssScript)
            print("üì± [WebView] iPhone CSS script added")
            
            // Inject iPhone-specific haptic feedback script
            print("üì± [WebView] Creating iPhone haptic feedback script")
            let hapticScript = WKUserScript(
                source: """
                // Haptic feedback for interactive elements - only on actual taps/clicks
                function addHapticFeedback() {
                    // Select all interactive elements
                    const interactiveElements = document.querySelectorAll('a, button, input, select, textarea, [role="button"], [tabindex], [onclick], [onmousedown], [ontouchstart]');
                    
                    interactiveElements.forEach(function(element) {
                        let touchStartTime = 0;
                        let touchStartY = 0;
                        let touchStartX = 0;
                        let hasMoved = false;
                        
                        // Track touch start
                        element.addEventListener('touchstart', function(e) {
                            touchStartTime = Date.now();
                            touchStartY = e.touches[0].clientY;
                            touchStartX = e.touches[0].clientX;
                            hasMoved = false;
                        }, { passive: true });
                        
                        // Track touch move to detect scrolling
                        element.addEventListener('touchmove', function(e) {
                            const currentY = e.touches[0].clientY;
                            const currentX = e.touches[0].clientX;
                            const deltaY = Math.abs(currentY - touchStartY);
                            const deltaX = Math.abs(currentX - touchStartX);
                            
                            // If moved more than 10px, consider it a scroll
                            if (deltaY > 10 || deltaX > 10) {
                                hasMoved = true;
                            }
                        }, { passive: true });
                        
                        // Only trigger haptic feedback on actual taps (not scrolls)
                        element.addEventListener('touchend', function(e) {
                            const touchEndTime = Date.now();
                            const touchDuration = touchEndTime - touchStartTime;
                            
                            // Only trigger if:
                            // 1. Touch duration is less than 300ms (quick tap)
                            // 2. No significant movement (not a scroll)
                            // 3. Touch ended on the same element
                            if (touchDuration < 300 && !hasMoved && e.target === element) {
                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                }
                            }
                        }, { passive: true });
                        
                        // For mouse events (iPhone with mouse), use click instead of mousedown
                        element.addEventListener('click', function(e) {
                            // Only trigger if it's a real click (not programmatic)
                            if (e.isTrusted) {
                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                }
                            }
                        }, { passive: true });
                    });
                    
                    // Also handle dynamically added elements
                    const observer = new MutationObserver(function(mutations) {
                        mutations.forEach(function(mutation) {
                            mutation.addedNodes.forEach(function(node) {
                                if (node.nodeType === 1) { // Element node
                                    const newInteractiveElements = node.querySelectorAll ? node.querySelectorAll('a, button, input, select, textarea, [role="button"], [tabindex], [onclick], [onmousedown], [ontouchstart]') : [];
                                    newInteractiveElements.forEach(function(element) {
                                        let touchStartTime = 0;
                                        let touchStartY = 0;
                                        let touchStartX = 0;
                                        let hasMoved = false;
                                        
                                        // Track touch start
                                        element.addEventListener('touchstart', function(e) {
                                            touchStartTime = Date.now();
                                            touchStartY = e.touches[0].clientY;
                                            touchStartX = e.touches[0].clientX;
                                            hasMoved = false;
                                        }, { passive: true });
                                        
                                        // Track touch move to detect scrolling
                                        element.addEventListener('touchmove', function(e) {
                                            const currentY = e.touches[0].clientY;
                                            const currentX = e.touches[0].clientX;
                                            const deltaX = Math.abs(currentX - touchStartX);
                                            const deltaY = Math.abs(currentY - touchStartY);
                                            
                                            // If moved more than 10px, consider it a scroll
                                            if (deltaY > 10 || deltaX > 10) {
                                                hasMoved = true;
                                            }
                                        }, { passive: true });
                                        
                                        // Only trigger haptic feedback on actual taps (not scrolls)
                                        element.addEventListener('touchend', function(e) {
                                            const touchEndTime = Date.now();
                                            const touchDuration = touchEndTime - touchStartTime;
                                            
                                            // Only trigger if:
                                            // 1. Touch duration is less than 300ms (quick tap)
                                            // 2. No significant movement (not a scroll)
                                            // 3. Touch ended on the same element
                                            if (touchDuration < 300 && !hasMoved && e.target === element) {
                                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                                }
                                            }
                                        }, { passive: true });
                                        
                                        // For mouse events (iPhone with mouse), use click instead of mousedown
                                        element.addEventListener('click', function(e) {
                                            // Only trigger if it's a real click (not programmatic)
                                            if (e.isTrusted) {
                                                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
                                                    window.webkit.messageHandlers.hapticFeedback.postMessage('light');
                                                }
                                            }
                                        }, { passive: true });
                                    });
                                }
                            });
                        });
                    });
                    
                    observer.observe(document.body, { childList: true, subtree: true });
                }
                
                // Initialize haptic feedback when DOM is ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', addHapticFeedback);
                } else {
                    addHapticFeedback();
                }
                
                // Also run on page load for single-page applications
                window.addEventListener('load', addHapticFeedback);
                """,
                injectionTime: .atDocumentEnd,
                forMainFrameOnly: true
            )
            userContentController.addUserScript(hapticScript)
            print("üì± [WebView] iPhone haptic feedback script added")
            
            // iPhone-specific application name
            configuration.applicationNameForUserAgent = "Zoobox iPhone"
            print("üì± [WebView] iPhone user agent set")
        }
        
        // Common WebView configuration for both devices
        print("üì± [WebView] Setting up common configuration")
        configuration.allowsInlineMediaPlayback = true
        configuration.mediaTypesRequiringUserActionForPlayback = []
        configuration.suppressesIncrementalRendering = true
        print("üì± [WebView] Common configuration completed")
        
        // Device-specific additional configurations
        if UIDevice.current.isIPad {
            // iPad-specific additional settings
            print("üì± [WebView] Setting up iPad-specific media settings")
            configuration.allowsAirPlayForMediaPlayback = true
            configuration.allowsPictureInPictureMediaPlayback = true
            print("üì± [WebView] iPad media settings completed")
        }
        
        // Create WebView with device-specific configuration
        print("üì± [WebView] Creating WKWebView with configuration")
        webView = NoZoomWKWebView(frame: view.bounds, configuration: configuration)
        webView.allowsLinkPreview = false
        webView.scrollView.pinchGestureRecognizer?.isEnabled = false
        
        // Additional native zoom prevention
        webView.scrollView.maximumZoomScale = 1.0
        webView.scrollView.minimumZoomScale = 1.0
        webView.scrollView.zoomScale = 1.0
        webView.scrollView.bouncesZoom = false
        print("üì± [WebView] WKWebView created successfully")
        webView.navigationDelegate = self
        webView.allowsBackForwardNavigationGestures = true
        webView.uiDelegate = self
        
        // Disable geolocation permission prompts completely
        webView.configuration.preferences.javaScriptCanOpenWindowsAutomatically = false
        webView.configuration.preferences.javaScriptEnabled = true
        
        // Additional settings to prevent permission dialogs
        webView.configuration.allowsInlineMediaPlayback = true
        webView.configuration.mediaTypesRequiringUserActionForPlayback = []
        
        // Set custom user agent to indicate this is a native app
        webView.customUserAgent = "Zoobox/2.0 (iOS; Native App)"
        
        // Device-specific WebView settings
        if UIDevice.current.isIPad {
            // iPad-specific settings
            webView.scrollView.contentInsetAdjustmentBehavior = .never
            webView.scrollView.automaticallyAdjustsScrollIndicatorInsets = false
            webView.scrollView.showsVerticalScrollIndicator = false
            webView.scrollView.showsHorizontalScrollIndicator = false
        } else {
            // iPhone-specific settings
            webView.scrollView.contentInsetAdjustmentBehavior = .never
            webView.scrollView.automaticallyAdjustsScrollIndicatorInsets = false
            webView.scrollView.showsVerticalScrollIndicator = false
            webView.scrollView.showsHorizontalScrollIndicator = false
        }
        
        // Enable webview scrolling for content
        webView.scrollView.isScrollEnabled = true
        webView.scrollView.bounces = true
        webView.scrollView.alwaysBounceVertical = true
        webView.scrollView.alwaysBounceHorizontal = false
        webView.scrollView.contentInsetAdjustmentBehavior = .never
        
        view.addSubview(webView)
        webView.translatesAutoresizingMaskIntoConstraints = false
        
        // Set up WebView constraints to fill the view
        NSLayoutConstraint.activate([
            webView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            webView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            webView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            webView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])
        

        
        // Add refresh control to WebView's scroll view
        webView.scrollView.refreshControl = refreshControl
        
        // Load default URL with device-specific timeout
        print("üîÑ [MainViewController] About to load initial URL")
        print("üì± [WebView] Device: \(UIDevice.current.deviceFamily)")
        print("üì± [WebView] Timeout: \(UIDevice.current.webViewTimeout) seconds")
        print("üì± [WebView] Max retries: \(UIDevice.current.maxRetryCount)")
        
        if let url = URL(string: "https://mikmik.site") {
            print("üì± [WebView] Loading URL: \(url)")
            loadURL(url)
        } else {
            print("‚ùå [WebView] Failed to create URL")
        }
        print("‚úÖ [MainViewController] WebView setup completed")
        
        // Setup permission bridge after WebView creation
        setupPermissionBridge()
        
        // Setup custom URL scheme handler for geolocation
        setupGeolocationURLSchemeHandler()
        
        } catch {
            print("‚ùå [WebView] Error during WebView setup: \(error)")
            print("‚ùå [WebView] Error details: \(error.localizedDescription)")
            
            // Fallback to basic WebView configuration
            print("üì± [WebView] Attempting fallback configuration")
            let fallbackConfiguration = WKWebViewConfiguration()
            webView = NoZoomWKWebView(frame: view.bounds, configuration: fallbackConfiguration)
            webView.allowsLinkPreview = false
            webView.scrollView.pinchGestureRecognizer?.isEnabled = false
            
            // Additional native zoom prevention
            webView.scrollView.maximumZoomScale = 1.0
            webView.scrollView.minimumZoomScale = 1.0
            webView.scrollView.zoomScale = 1.0
            webView.scrollView.bouncesZoom = false
            webView.navigationDelegate = self
            
            if let url = URL(string: "https://mikmik.site") {
                loadURL(url)
            }
        }
    }
    

    
    @objc private func handleRefresh() {
        isRefreshing = true
        
        // Check connectivity first
        let isConnected = ConnectivityManager.shared.currentConnectivityStatus == .connected
        
        if !isConnected {
            // Device-specific refresh control styling
            let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
            let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
            
            // Show no internet connection message
            refreshControl.attributedTitle = NSAttributedString(
                string: "No internet connection",
                attributes: [
                    .foregroundColor: UIColor.systemOrange,
                    .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
                ]
            )
            
            // End refreshing immediately
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
                self.refreshControl.endRefreshing()
                self.isRefreshing = false
                
                // Reset to default state after a delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    self.updateRefreshControlForConnectivity()
                }
            }
            return
        }
        
        // Haptic feedback
        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
        impactFeedback.impactOccurred()
        
        // Update refresh control title with device-specific styling
        let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
        let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
        
        refreshControl.attributedTitle = NSAttributedString(
            string: "Refreshing...",
            attributes: [
                .foregroundColor: UIColor.systemBlue,
                .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            ]
        )
        
        // Reload the current page
        if let currentURL = webView.url {
            loadURL(currentURL)
        } else if let url = URL(string: "https://mikmik.site") {
            loadURL(url)
        }
    }
    
    private func showRefreshSuccess() {
        // Haptic feedback
        let notificationFeedback = UINotificationFeedbackGenerator()
        notificationFeedback.notificationOccurred(.success)
        
        // Device-specific refresh control styling
        let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
        let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
        
        // Update refresh control with success state
        refreshControl.attributedTitle = NSAttributedString(
            string: "Refreshed successfully",
            attributes: [
                .foregroundColor: UIColor.systemGreen,
                .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            ]
        )
        
        // End refreshing after a short delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.refreshControl.endRefreshing()
            self.isRefreshing = false
            
            // Reset to default state after a delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.refreshControl.attributedTitle = NSAttributedString(
                    string: "Pull to refresh",
                    attributes: [
                        .foregroundColor: UIColor.systemBlue,
                        .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
                    ]
                )
            }
        }
    }
    
    private func showRefreshError() {
        // Haptic feedback
        let notificationFeedback = UINotificationFeedbackGenerator()
        notificationFeedback.notificationOccurred(.error)
        
        // Device-specific refresh control styling
        let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
        let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
        
        // Update refresh control with error state
        refreshControl.attributedTitle = NSAttributedString(
            string: "Refresh failed",
            attributes: [
                .foregroundColor: UIColor.systemRed,
                .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
            ]
        )
        
        // End refreshing after a short delay
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            self.refreshControl.endRefreshing()
            self.isRefreshing = false
            
            // Reset to default state after a delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self.refreshControl.attributedTitle = NSAttributedString(
                    string: "Pull to refresh",
                    attributes: [
                        .foregroundColor: UIColor.systemBlue,
                        .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
                    ]
                )
            }
        }
    }
    
    private func setupConnectivityManager() {
        ConnectivityManager.shared.delegate = self
    }
    
    private func setupNotificationObservers() {
        // Listen for FCM deep link notifications
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleDeepLinkNotification),
            name: NSNotification.Name("OpenDeepLinkURL"),
            object: nil
        )
    }
    
    private func setupPermissionBridge() {
        // Add permission bridge message handler
        webView.configuration.userContentController.add(self, name: "permissionBridge")
        
        // Inject permission bridge JavaScript
        let permissionBridgeScript = WKUserScript(
            source: """
            // Permission Bridge for Native App Integration
            window.ZooboxPermissionBridge = {
                // Check if permission is granted natively
                checkPermission: function(permissionType) {
                    return new Promise((resolve) => {
                        window.webkit.messageHandlers.permissionBridge.postMessage({
                            action: 'checkPermission',
                            permissionType: permissionType
                        });
                        
                        // Store the resolve function to be called by native code
                        if (!window._permissionCallbacks) {
                            window._permissionCallbacks = {};
                        }
                        window._permissionCallbacks[permissionType] = resolve;
                    });
                },
                
                // Check camera permission
                checkCameraPermission: function() {
                    return this.checkPermission('camera');
                },
                
                // Check location permission
                checkLocationPermission: function() {
                    return this.checkPermission('location');
                },
                
                // Check microphone permission
                checkMicrophonePermission: function() {
                    return this.checkPermission('microphone');
                },
                
                // Get all permission statuses at once
                getAllPermissions: function() {
                    return new Promise((resolve) => {
                        window.webkit.messageHandlers.permissionBridge.postMessage({
                            action: 'getAllPermissions'
                        });
                        
                        if (!window._permissionCallbacks) {
                            window._permissionCallbacks = {};
                        }
                        window._permissionCallbacks['all'] = resolve;
                    });
                },
                
                // Helper function to resolve permission callbacks (called by native code)
                _resolvePermission: function(permissionType, isGranted) {
                    if (window._permissionCallbacks && window._permissionCallbacks[permissionType]) {
                        window._permissionCallbacks[permissionType](isGranted);
                        delete window._permissionCallbacks[permissionType];
                    }
                },
                
                // Helper function to resolve all permissions callback (called by native code)
                _resolveAllPermissions: function(permissions) {
                    if (window._permissionCallbacks && window._permissionCallbacks['all']) {
                        window._permissionCallbacks['all'](permissions);
                        delete window._permissionCallbacks['all'];
                    }
                }
            };
            
            // Make it globally available
            window.zooboxPermissions = window.ZooboxPermissionBridge;
            
            // Completely override geolocation API to bypass browser permission system
            (function() {
                if (navigator.geolocation) {
                    // Store original methods
                    const originalGetCurrentPosition = navigator.geolocation.getCurrentPosition;
                    const originalWatchPosition = navigator.geolocation.watchPosition;
                    const originalClearWatch = navigator.geolocation.clearWatch;
                    
                    // Override getCurrentPosition with immediate native permission check
                    navigator.geolocation.getCurrentPosition = function(successCallback, errorCallback, options) {
                        // Immediately check native permission status
                        window.ZooboxPermissionBridge.checkLocationPermission().then(function(isGranted) {
                            if (isGranted) {
                                // Permission granted, call original method directly
                                console.log('üîê Native location permission granted, bypassing browser prompt');
                                originalGetCurrentPosition.call(navigator.geolocation, successCallback, errorCallback, options);
                            } else {
                                // Permission not granted, show custom message or call original
                                console.log('üîê Native location permission not granted, showing prompt');
                                if (errorCallback) {
                                    errorCallback({
                                        code: 1, // PERMISSION_DENIED
                                        message: 'Location permission not granted'
                                    });
                                }
                            }
                        }).catch(function(error) {
                            console.error('üîê Error checking location permission:', error);
                            // Fallback to original method
                            originalGetCurrentPosition.call(navigator.geolocation, successCallback, errorCallback, options);
                        });
                    };
                    
                    // Override watchPosition with immediate native permission check
                    navigator.geolocation.watchPosition = function(successCallback, errorCallback, options) {
                        // Immediately check native permission status
                        window.ZooboxPermissionBridge.checkLocationPermission().then(function(isGranted) {
                            if (isGranted) {
                                // Permission granted, call original method directly
                                console.log('üîê Native location permission granted, bypassing browser prompt for watch');
                                return originalWatchPosition.call(navigator.geolocation, successCallback, errorCallback, options);
                            } else {
                                // Permission not granted, show custom message or call original
                                console.log('üîê Native location permission not granted for watch');
                                if (errorCallback) {
                                    errorCallback({
                                        code: 1, // PERMISSION_DENIED
                                        message: 'Location permission not granted'
                                    });
                                }
                                return -1; // Invalid watch ID
                            }
                        }).catch(function(error) {
                            console.error('üîê Error checking location permission for watch:', error);
                            // Fallback to original method
                            return originalWatchPosition.call(navigator.geolocation, successCallback, errorCallback, options);
                        });
                    };
                    
                    // Keep original clearWatch
                    navigator.geolocation.clearWatch = originalClearWatch;
                }
            })();
            
            // Prevent any geolocation permission dialogs by overriding permission query
            (function() {
                // Override any permission query methods that might trigger dialogs
                if (navigator.permissions) {
                    const originalQuery = navigator.permissions.query;
                    navigator.permissions.query = function(permissionDesc) {
                        if (permissionDesc.name === 'geolocation') {
                            return new Promise((resolve) => {
                                window.ZooboxPermissionBridge.checkLocationPermission().then(function(isGranted) {
                                    resolve({
                                        state: isGranted ? 'granted' : 'denied',
                                        onchange: null
                                    });
                                });
                            });
                        }
                        return originalQuery.call(navigator.permissions, permissionDesc);
                    };
                }
            })();
            
            console.log('Zoobox Permission Bridge initialized with complete geolocation override');
            """,
            injectionTime: .atDocumentStart,
            forMainFrameOnly: true
        )
        
        webView.configuration.userContentController.addUserScript(permissionBridgeScript)
    }
    
    private func setupGeolocationURLSchemeHandler() {
        // Add custom URL scheme handler for geolocation
        let geolocationHandler = GeolocationURLSchemeHandler()
        webView.configuration.setURLSchemeHandler(geolocationHandler, forURLScheme: "geolocation")
        
        // Inject script to intercept geolocation requests
        let geolocationInterceptScript = WKUserScript(
            source: """
            // Intercept and handle geolocation requests at the URL level
            (function() {
                // Override any geolocation-related URL requests
                const originalFetch = window.fetch;
                window.fetch = function(url, options) {
                    if (typeof url === 'string' && url.includes('geolocation')) {
                        console.log('üîê Intercepted geolocation fetch request:', url);
                        // Return a mock response or handle differently
                        return Promise.resolve(new Response(JSON.stringify({error: 'Geolocation handled by native app'}), {
                            status: 200,
                            headers: {'Content-Type': 'application/json'}
                        }));
                    }
                    return originalFetch.apply(this, arguments);
                };
                
                // Override XMLHttpRequest for geolocation
                const originalOpen = XMLHttpRequest.prototype.open;
                XMLHttpRequest.prototype.open = function(method, url, async, user, password) {
                    if (typeof url === 'string' && url.includes('geolocation')) {
                        console.log('üîê Intercepted geolocation XHR request:', url);
                        // Handle geolocation request differently
                        this.addEventListener('readystatechange', function() {
                            if (this.readyState === 4) {
                                this.status = 200;
                                this.responseText = JSON.stringify({error: 'Geolocation handled by native app'});
                                this.responseType = 'json';
                            }
                        });
                    }
                    return originalOpen.apply(this, arguments);
                };
            })();
            """,
            injectionTime: .atDocumentStart,
            forMainFrameOnly: true
        )
        
        webView.configuration.userContentController.addUserScript(geolocationInterceptScript)
    }
    
    @objc private func handleDeepLinkNotification(_ notification: Notification) {
        guard let userInfo = notification.userInfo,
              let url = userInfo["url"] as? URL else {
            print("üîó Invalid deep link notification data")
            return
        }
        
        print("üîó Handling FCM deep link: \(url)")
        
        // Load the deep link URL in the WebView
        DispatchQueue.main.async {
            self.loadURL(url)
        }
    }
    
    private func updateRefreshControlForConnectivity() {
        let isConnected = ConnectivityManager.shared.currentConnectivityStatus == .connected
        
        // Device-specific refresh control styling
        let fontSize: CGFloat = UIDevice.current.isIPad ? 16 : 14
        let fontWeight: UIFont.Weight = UIDevice.current.isIPad ? .semibold : .medium
        
        if !isConnected {
            refreshControl.attributedTitle = NSAttributedString(
                string: "No internet connection",
                attributes: [
                    .foregroundColor: UIColor.systemOrange,
                    .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
                ]
            )
        } else {
            refreshControl.attributedTitle = NSAttributedString(
                string: "Pull to refresh",
                attributes: [
                    .foregroundColor: UIColor.systemBlue,
                    .font: UIFont.systemFont(ofSize: fontSize, weight: fontWeight)
                ]
            )
        }
    }
    
    func loadURL(_ url: URL) {
        print("üîÑ [MainViewController] loadURL called with: \(url)")
        print("‚è∞ [MainViewController] loadURL time: \(Date())")
        
        // Cancel any existing timer
        loadingTimer?.invalidate()
        
        let request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: loadingTimeout)
        currentNavigation = webView.load(request)
        retryCount = 0
        lastError = nil
        
        // Start loading timer
        startLoadingTimer()
        
        print("‚úÖ [MainViewController] loadURL completed")
    }
    
    private func startLoadingTimer() {
        loadingTimer?.invalidate()
        loadingTimer = Timer.scheduledTimer(withTimeInterval: loadingTimeout, repeats: false) { [weak self] _ in
            self?.handleLoadingTimeout()
        }
    }
    
    private func handleLoadingTimeout() {
        print("‚è∞ Loading timeout occurred")
        
        // Cancel current navigation if it exists
        if let navigation = currentNavigation {
            webView.stopLoading()
        }
        
        let timeoutError = NSError(domain: NSURLErrorDomain, code: NSURLErrorTimedOut, userInfo: [
            NSLocalizedDescriptionKey: "Request timed out"
        ])
        
        handleWebViewError(timeoutError)
        
        // If refresh control is refreshing, show error
        if refreshControl.isRefreshing {
            showRefreshError()
        }
    }
    
    private func retryLoad() {
        guard retryCount < maxRetryCount else {
            showMaxRetryError()
            return
        }
        
        retryCount += 1
        print("üîÑ Retrying load (attempt \(retryCount)/\(maxRetryCount))")
        
        if let currentURL = webView.url {
            loadURL(currentURL)
        } else if let url = URL(string: "https://mikmik.site") {
            loadURL(url)
        }
    }
    
    private func showMaxRetryError() {
        let alert = UIAlertController(
            title: "Connection Failed",
            message: "Unable to load the page after multiple attempts. Please check your internet connection and try again.",
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Try Again", style: .default) { _ in
            self.retryCount = 0
            self.loadMainSite()
        })
        
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        
        present(alert, animated: true)
    }
    
    private func loadMainSite() {
        if let url = URL(string: "https://mikmik.site") {
            loadURL(url)
        }
    }
    
    private func handleWebViewError(_ error: Error) {
        lastError = error
        let nsError = error as NSError
        
        print("‚ùå WebView Error: \(error.localizedDescription)")
        print("‚ùå Error Domain: \(nsError.domain)")
        print("‚ùå Error Code: \(nsError.code)")
        
        // Categorize error and show appropriate message
        let errorMessage = categorizeError(error)
        showErrorAlert(title: "Loading Error", message: errorMessage)
    }
    
    private func categorizeError(_ error: Error) -> String {
        let nsError = error as NSError
        
        switch nsError.domain {
        case NSURLErrorDomain:
            return categorizeURLError(nsError)
        case "WKErrorDomain":
            return categorizeWKError(nsError)
        default:
            return "An unexpected error occurred. Please try again."
        }
    }
    
    private func categorizeURLError(_ error: NSError) -> String {
        switch error.code {
        case NSURLErrorNotConnectedToInternet:
            return "No internet connection. Please check your network settings and try again."
        case NSURLErrorNetworkConnectionLost:
            return "Network connection was lost. Please check your connection and try again."
        case NSURLErrorTimedOut:
            return "Request timed out. The server is taking too long to respond."
        case NSURLErrorCannotFindHost:
            return "Cannot find the server. Please check the URL and try again."
        case NSURLErrorCannotConnectToHost:
            return "Cannot connect to the server. The server may be down or unreachable."
        case NSURLErrorBadServerResponse:
            return "Server error. The server returned an invalid response."
        case NSURLErrorUnsupportedURL:
            return "Unsupported URL format. Please check the address."
        case NSURLErrorSecureConnectionFailed:
            return "Secure connection failed. There may be a security issue with the server."
        default:
            return "Network error occurred. Please try again."
        }
    }
    
    private func categorizeWKError(_ error: NSError) -> String {
        switch error.code {
        case 102: // WKErrorFrameLoadInterruptedByPolicyChange
            return "Page load was interrupted. Please try again."
        case 103: // WKErrorCannotShowURL
            return "Cannot display this URL. The content may not be supported."
        case 104: // WKErrorCancelled
            return "Request was cancelled. Please try again."
        case 105: // WKErrorJavaScriptExceptionOccurred
            return "A JavaScript error occurred on the page."
        case 106: // WKErrorJavaScriptResultTypeIsUnsupported
            return "JavaScript result type is not supported."
        default:
            return "Web page error occurred. Please try again."
        }
    }
    
    private func showErrorAlert(title: String, message: String) {
        // Device-specific alert styling
        let alertStyle: UIAlertController.Style = UIDevice.current.isIPad ? .alert : .alert
        
        let alert = UIAlertController(title: title, message: message, preferredStyle: alertStyle)
        
        // Device-specific button styling
        let retryAction = UIAlertAction(title: "Retry", style: .default) { _ in
            self.retryLoad()
        }
        
        let cancelAction = UIAlertAction(title: "Cancel", style: .cancel)
        
        alert.addAction(retryAction)
        alert.addAction(cancelAction)
        
        // iPad-specific popover presentation
        if UIDevice.current.isIPad {
            if let popover = alert.popoverPresentationController {
                popover.sourceView = self.view
                popover.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0)
                popover.permittedArrowDirections = []
            }
        }
        
        present(alert, animated: true)
    }
}

// MARK: - WKNavigationDelegate
extension MainViewController: WKNavigationDelegate {
    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        print("üîÑ [WebView] didStartProvisionalNavigation called")
        print("‚è∞ [WebView] didStartProvisionalNavigation time: \(Date())")
        print("üì± [WebView] Device: \(UIDevice.current.deviceFamily)")
        print("üì± [WebView] Orientation: \(UIDevice.current.orientationString)")
        print("üì± [WebView] Screen size: \(UIScreen.main.bounds.size)")
        
        currentNavigation = navigation
        startLoadingTimer()
        
        // Keep loading indicator visible during webview loading
        print("üì± [WebView] Keeping loading indicator visible during webview loading")
        
        print("‚úÖ [WebView] didStartProvisionalNavigation completed")
    }
    
    func webView(_ webView: WKWebView, didCommit navigation: WKNavigation!) {
        print("üìÑ WebView committed navigation")
    }
    
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        // Ensure we're on main thread
        DispatchQueue.main.async { [weak self] in
            guard let self = self else { return }
            
            self.isWebViewLoaded = true
            
            // Safely evaluate pending JavaScript responses
            for js in self.pendingJSResponses {
                // Add safety check for WebView
                guard let webView = self.webView else {
                    print("üîê WebView is nil, skipping JavaScript evaluation")
                    break
                }
                
                webView.evaluateJavaScript(js) { result, error in
                    if let error = error {
                        print("üîê Error evaluating pending JavaScript: \(error)")
                    }
                }
            }
            self.pendingJSResponses.removeAll()
            print("‚úÖ [WebView] didFinish called - WebView loaded successfully")
            print("‚è∞ [WebView] didFinish time: \(Date())")
            print("üì± [WebView] Device: \(UIDevice.current.deviceFamily)")
            print("üì± [WebView] Orientation: \(UIDevice.current.orientationString)")
            print("üì± [WebView] Screen size: \(UIScreen.main.bounds.size)")
            
            // Cancel loading timer
            loadingTimer?.invalidate()
            
            // Reset error state on successful load
            lastError = nil
            retryCount = 0
            
            // Hide loading indicator when webview finishes loading with a small delay
            print("üì± [WebView] Hiding loading indicator - webview finished loading")
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                LoadingIndicatorManager.shared.hideLoadingIndicator()
            }
            
            
            
            
            
            // If refresh control is refreshing, show success
            if refreshControl.isRefreshing {
                showRefreshSuccess()
            }
            
            print("‚úÖ [WebView] didFinish completed")
        }
        
        
        
        
        
        func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {
            print("‚ùå WebView failed to load: \(error)")
            
            // Cancel loading timer
            loadingTimer?.invalidate()
            
            // Hide loading indicator when webview fails
            print("üì± [WebView] Hiding loading indicator - webview failed")
            LoadingIndicatorManager.shared.hideLoadingIndicator()
            
            // Check for authentication/sign-in errors
            if isAuthenticationError(error) {
                handleAuthenticationError(error)
                return
            }
            
            // Handle error
            handleWebViewError(error)
            
            // If refresh control is refreshing, show error
            if refreshControl.isRefreshing {
                showRefreshError()
            }
        }
        
        func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
            print("‚ùå WebView failed to load (provisional): \(error)")
            
            // Cancel loading timer
            loadingTimer?.invalidate()
            
            // Hide loading indicator when webview fails
            print("üì± [WebView] Hiding loading indicator - webview failed (provisional)")
            LoadingIndicatorManager.shared.hideLoadingIndicator()
            
            // Check for authentication/sign-in errors
            if isAuthenticationError(error) {
                handleAuthenticationError(error)
                return
            }
            
            // Handle error
            handleWebViewError(error)
            
            // If refresh control is refreshing, show error
            if refreshControl.isRefreshing {
                showRefreshError()
            }
        }
        
        func webView(_ webView: WKWebView, didReceiveServerRedirectForProvisionalNavigation navigation: WKNavigation!) {
            print("üîÑ WebView received server redirect")
        }
        
        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
            // Allow all navigation actions by default
            decisionHandler(.allow)
        }
        
        func webView(_ webView: WKWebView, decidePolicyFor navigationResponse: WKNavigationResponse, decisionHandler: @escaping (WKNavigationResponsePolicy) -> Void) {
            // Allow all navigation responses by default
            decisionHandler(.allow)
        }
        
        // MARK: - Authentication Error Handling
        
        private func isAuthenticationError(_ error: Error) -> Bool {
            let errorDescription = error.localizedDescription.lowercased()
            let errorDomain = (error as NSError).domain
            
            // Check for common authentication error patterns
            return errorDescription.contains("sign") ||
            errorDescription.contains("login") ||
            errorDescription.contains("authentication") ||
            errorDescription.contains("unauthorized") ||
            errorDescription.contains("forbidden") ||
            errorDomain.contains("authentication") ||
            (error as NSError).code == 401 ||
            (error as NSError).code == 403
        }
        
        private func handleAuthenticationError(_ error: Error) {
            print("üîê Authentication error detected: \(error)")
            
            // Show user-friendly authentication error
            DispatchQueue.main.async {
                let alert = UIAlertController(
                    title: "Connection Issue",
                    message: "There was a temporary issue connecting to Zoobox. Please try again in a moment.",
                    preferredStyle: .alert
                )
                
                alert.addAction(UIAlertAction(title: "Retry", style: .default) { _ in
                    self.retryLoad()
                })
                
                alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
                
                // iPad-specific popover presentation
                if UIDevice.current.isIPad {
                    if let popover = alert.popoverPresentationController {
                        popover.sourceView = self.view
                        popover.sourceRect = CGRect(x: self.view.bounds.midX, y: self.view.bounds.midY, width: 0, height: 0)
                        popover.permittedArrowDirections = []
                    }
                }
                
                self.present(alert, animated: true)
            }
        }
    }
    
    // MARK: - WKScriptMessageHandler
    extension MainViewController: WKScriptMessageHandler {
        func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
            if message.name == "hapticFeedback" {
                handleHapticFeedback(message: message)
            } else if message.name == "permissionBridge" {
                handlePermissionBridge(message: message)
            }
        }
        
        private func handleHapticFeedback(message: WKScriptMessage) {
            guard let feedbackType = message.body as? String else { return }
            
            print("üì± [HapticFeedback] Triggering \(feedbackType) haptic feedback")
            
            DispatchQueue.main.async {
                switch feedbackType {
                case "light":
                    let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                    impactFeedback.impactOccurred()
                case "medium":
                    let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
                    impactFeedback.impactOccurred()
                case "heavy":
                    let impactFeedback = UIImpactFeedbackGenerator(style: .heavy)
                    impactFeedback.impactOccurred()
                case "success":
                    let notificationFeedback = UINotificationFeedbackGenerator()
                    notificationFeedback.notificationOccurred(.success)
                case "warning":
                    let notificationFeedback = UINotificationFeedbackGenerator()
                    notificationFeedback.notificationOccurred(.warning)
                case "error":
                    let notificationFeedback = UINotificationFeedbackGenerator()
                    notificationFeedback.notificationOccurred(.error)
                default:
                    let impactFeedback = UIImpactFeedbackGenerator(style: .light)
                    impactFeedback.impactOccurred()
                }
            }
        }
        
        private func handlePermissionBridge(message: WKScriptMessage) {
            guard let body = message.body as? [String: Any],
                  let action = body["action"] as? String else {
                print("üîê Invalid permission bridge message")
                return
            }
            
            switch action {
            case "checkPermission":
                handleCheckPermission(body)
            case "getAllPermissions":
                handleGetAllPermissions()
            default:
                print("üîê Unknown permission bridge action: \(action)")
            }
        }
        
        private func handleCheckPermission(_ body: [String: Any]) {
            guard let permissionType = body["permissionType"] as? String else {
                print("üîê Missing permission type in checkPermission")
                return
            }
            
            DispatchQueue.global(qos: .userInitiated).async { [weak self] in
                let isGranted: Bool
                switch permissionType {
                case "camera":
                    isGranted = AVCaptureDevice.authorizationStatus(for: .video) == .authorized
                case "location":
                    let locationStatus = CLLocationManager.authorizationStatus()
                    isGranted = locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse
                case "microphone":
                    isGranted = AVCaptureDevice.authorizationStatus(for: .audio) == .authorized
                default:
                    isGranted = false
                }
                DispatchQueue.main.async { [weak self] in
                    guard let self = self else {
                        print("üîê Self is nil, skipping permission response")
                        return
                    }
                    
                    guard let webView = self.webView else {
                        print("üîê WebView is nil, skipping permission response")
                        return
                    }
                    
                    let responseScript = "window.ZooboxPermissionBridge._resolvePermission('\(permissionType)', \(isGranted));"
                    
                    if self.isWebViewLoaded {
                        // Add safety check before evaluation
                        webView.evaluateJavaScript(responseScript) { result, error in
                            if let error = error {
                                print("üîê Error resolving permission callback: \(error)")
                            }
                        }
                    } else {
                        self.pendingJSResponses.append(responseScript)
                    }
                    print("üîê Permission check for \(permissionType): \(isGranted)")
                }
            }
        }
        
        private func handleGetAllPermissions() {
            DispatchQueue.global(qos: .userInitiated).async { [weak self] in
                let permissions: [String: Bool] = [
                    "camera": AVCaptureDevice.authorizationStatus(for: .video) == .authorized,
                    "location": {
                        let locationStatus = CLLocationManager.authorizationStatus()
                        return locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse
                    }(),
                    "microphone": AVCaptureDevice.authorizationStatus(for: .audio) == .authorized
                ]
                DispatchQueue.main.async { [weak self] in
                    guard let self = self else {
                        print("üîê Self is nil, skipping all permissions response")
                        return
                    }
                    
                    guard let webView = self.webView else {
                        print("üîê WebView is nil, skipping all permissions response")
                        return
                    }
                    
                    if let jsonData = try? JSONSerialization.data(withJSONObject: permissions),
                       let jsonString = String(data: jsonData, encoding: .utf8) {
                        let responseScript = "window.ZooboxPermissionBridge._resolveAllPermissions(\(jsonString));"
                        
                        if self.isWebViewLoaded {
                            // Add safety check before evaluation
                            webView.evaluateJavaScript(responseScript) { result, error in
                                if let error = error {
                                    print("üîê Error resolving all permissions callback: \(error)")
                                }
                            }
                        } else {
                            self.pendingJSResponses.append(responseScript)
                        }
                    }
                    print("üîê All permissions status: \(permissions)")
                }
            }
        }
    }
    
    // MARK: - ConnectivityManagerDelegate
    extension MainViewController: ConnectivityManagerDelegate {
        func connectivityManager(_ manager: ConnectivityManager, didUpdateConnectivityStatus status: ConnectivityStatus) {
            DispatchQueue.main.async {
                self.updateRefreshControlForConnectivity()
            }
        }
        
        func connectivityManager(_ manager: ConnectivityManager, didUpdateGPSStatus enabled: Bool) {
            // GPS status updates can be handled here if needed
            print("üì° GPS status updated: \(enabled)")
        }
    }
    
    // MARK: - WKUIDelegate
    extension MainViewController: WKUIDelegate {
        // iOS 15+: Intercept media (camera/microphone) permission requests
        func webView(_ webView: WKWebView, requestMediaCapturePermissionFor origin: WKSecurityOrigin, initiatedByFrame frame: WKFrameInfo, type: WKMediaCaptureType, decisionHandler: @escaping (WKPermissionDecision) -> Void) {
            if type == .camera {
                // Move to background thread to prevent main thread blocking
                DispatchQueue.global(qos: .userInitiated).async {
                    let cameraStatus = AVCaptureDevice.authorizationStatus(for: .video)
                    DispatchQueue.main.async { [weak self] in
                        guard let _ = self else {
                            decisionHandler(.prompt)
                            return
                        }
                        
                        if cameraStatus == .authorized {
                            decisionHandler(.grant)
                            return
                        }
                        // For microphone or if not granted, use default prompt
                        decisionHandler(.prompt)
                    }
                }
            } else {
                // For microphone or if not granted, use default prompt
                decisionHandler(.prompt)
            }
        }
        
        // iOS 15+: Intercept geolocation permission requests
        func webView(_ webView: WKWebView, requestGeolocationPermissionFor origin: WKSecurityOrigin, initiatedByFrame frame: WKFrameInfo, decisionHandler: @escaping (WKPermissionDecision) -> Void) {
            // Move to background thread to prevent main thread blocking
            DispatchQueue.global(qos: .userInitiated).async {
                let locationStatus = CLLocationManager.authorizationStatus()
                DispatchQueue.main.async { [weak self] in
                    guard let _ = self else {
                        decisionHandler(.prompt)
                        return
                    }
                    
                    if locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse {
                        decisionHandler(.grant)
                        return
                    }
                    decisionHandler(.prompt)
                }
            }
        }
        
        // Handle JavaScript alerts (including geolocation prompts)
        func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
            // Check if this is a geolocation permission request
            if message.contains("would like to use your current location") ||
                message.contains("use your precise location") ||
                message.contains("mikmik.site") {
                
                // Move to background thread to prevent main thread blocking
                DispatchQueue.global(qos: .userInitiated).async {
                    let locationStatus = CLLocationManager.authorizationStatus()
                    DispatchQueue.main.async { [weak self] in
                        guard let self = self else {
                            completionHandler()
                            return
                        }
                        
                        if locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse {
                            // Permission already granted, automatically allow
                            print("üîê Geolocation permission already granted, automatically allowing")
                            completionHandler()
                            return
                        }
                        
                        // For other alerts, show normal alert
                        let alert = UIAlertController(title: "Zoobox", message: message, preferredStyle: .alert)
                        alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                            completionHandler()
                        })
                        self.present(alert, animated: true)
                    }
                }
            } else {
                // For other alerts, show normal alert
                let alert = UIAlertController(title: "Zoobox", message: message, preferredStyle: .alert)
                alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                    completionHandler()
                })
                present(alert, animated: true)
            }
        }
        
        // Handle JavaScript confirm dialogs (including geolocation permission dialogs)
        func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
            // Check if this is a geolocation permission request
            if message.contains("would like to use your current location") ||
                message.contains("use your precise location") ||
                message.contains("mikmik.site") {
                
                // Move to background thread to prevent main thread blocking
                DispatchQueue.global(qos: .userInitiated).async {
                    let locationStatus = CLLocationManager.authorizationStatus()
                    DispatchQueue.main.async { [weak self] in
                        guard let self = self else {
                            completionHandler(false)
                            return
                        }
                        
                        if locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse {
                            // Permission already granted, automatically allow
                            print("üîê Geolocation permission already granted, automatically allowing")
                            completionHandler(true)
                            return
                        }
                        
                        // For other confirms, show normal alert
                        let alert = UIAlertController(title: "Zoobox", message: message, preferredStyle: .alert)
                        alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                            completionHandler(true)
                        })
                        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                            completionHandler(false)
                        })
                        self.present(alert, animated: true)
                    }
                }
            } else {
                // For other confirms, show normal alert
                let alert = UIAlertController(title: "Zoobox", message: message, preferredStyle: .alert)
                alert.addAction(UIAlertAction(title: "OK", style: .default) { _ in
                    completionHandler(true)
                })
                alert.addAction(UIAlertAction(title: "Cancel", style: .cancel) { _ in
                    completionHandler(false)
                })
                present(alert, animated: true)
            }
        }
    }
    
    // MARK: - Geolocation URL Scheme Handler
    class GeolocationURLSchemeHandler: NSObject, WKURLSchemeHandler {
        func webView(_ webView: WKWebView, start urlSchemeTask: WKURLSchemeTask) {
            print("üîê Geolocation URL scheme request intercepted: \(urlSchemeTask.request.url?.absoluteString ?? "unknown")")
            
            // Move to background thread to prevent main thread blocking
            DispatchQueue.global(qos: .userInitiated).async {
                // Check if native location permission is granted
                let locationStatus = CLLocationManager.authorizationStatus()
                
                DispatchQueue.main.async {
                    if locationStatus == .authorizedAlways || locationStatus == .authorizedWhenInUse {
                        // Permission granted, return success response
                        let response = HTTPURLResponse(
                            url: urlSchemeTask.request.url!,
                            statusCode: 200,
                            httpVersion: "HTTP/1.1",
                            headerFields: ["Content-Type": "application/json"]
                        )
                        
                        let responseData = "{\"status\":\"granted\",\"message\":\"Location permission already granted\"}".data(using: .utf8)
                        
                        urlSchemeTask.didReceive(response!)
                        urlSchemeTask.didReceive(responseData!)
                        urlSchemeTask.didFinish()
                        
                        print("üîê Geolocation request handled - permission already granted")
                    } else {
                        // Permission not granted, return error response
                        let response = HTTPURLResponse(
                            url: urlSchemeTask.request.url!,
                            statusCode: 403,
                            httpVersion: "HTTP/1.1",
                            headerFields: ["Content-Type": "application/json"]
                        )
                        
                        let responseData = "{\"error\":\"Location permission not granted\"}".data(using: .utf8)
                        
                        urlSchemeTask.didReceive(response!)
                        urlSchemeTask.didReceive(responseData!)
                        urlSchemeTask.didFinish()
                        
                        print("üîê Geolocation request handled - permission not granted")
                    }
                }
            }
        }
        
        func webView(_ webView: WKWebView, stop urlSchemeTask: WKURLSchemeTask) {
            print("üîê Geolocation URL scheme task stopped")
        }
    }

